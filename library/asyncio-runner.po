# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-29 17:18+0300\n"
"PO-Revision-Date: 2022-07-05 15:37+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Runners"
msgstr "Бігуни"

msgid "**Source code:** :source:`Lib/asyncio/runners.py`"
msgstr "**Вихідний код:** :source:`Lib/asyncio/runners.py`"

msgid ""
"This section outlines high-level asyncio primitives to run asyncio code."
msgstr ""
"У цьому розділі описано асинхронні примітиви високого рівня для запуску "
"асинхронного коду."

msgid ""
"They are built on top of an :ref:`event loop <asyncio-event-loop>` with the "
"aim to simplify async code usage for common wide-spread scenarios."
msgstr ""
"Вони побудовані на основі :ref:`циклу подій <asyncio-event-loop>` з метою "
"спрощення використання асинхронного коду для звичайних широко поширених "
"сценаріїв."

msgid "Running an asyncio Program"
msgstr "Запуск асинхронної програми"

msgid "Execute the :term:`coroutine` *coro* and return the result."
msgstr "Виконайте :term:`coroutine` *coro* і поверніть результат."

msgid ""
"This function runs the passed coroutine, taking care of managing the asyncio "
"event loop, *finalizing asynchronous generators*, and closing the threadpool."
msgstr ""
"Ця функція запускає передану співпрограму, піклуючись про керування циклом "
"асинхронних подій, *завершення асинхронних генераторів* і закриття пулу "
"потоків."

msgid ""
"This function cannot be called when another asyncio event loop is running in "
"the same thread."
msgstr ""
"Цю функцію не можна викликати, коли в тому самому потоці виконується інший "
"асинхронний цикл подій."

msgid ""
"If *debug* is ``True``, the event loop will be run in debug mode. ``False`` "
"disables debug mode explicitly. ``None`` is used to respect the global :ref:"
"`asyncio-debug-mode` settings."
msgstr ""
"Якщо *debug* має значення ``True``, цикл подій запускатиметься в режимі "
"налагодження. ``False`` явно вимикає режим налагодження. ``None`` "
"використовується для дотримання глобальних налаштувань :ref:`asyncio-debug-"
"mode`."

msgid ""
"This function always creates a new event loop and closes it at the end.  It "
"should be used as a main entry point for asyncio programs, and should "
"ideally only be called once."
msgstr ""
"Ця функція завжди створює новий цикл подій і закриває його в кінці. Його "
"слід використовувати як основну точку входу для асинхронних програм, і в "
"ідеалі його слід викликати лише один раз."

msgid "Example::"
msgstr "Приклад::"

msgid "Updated to use :meth:`loop.shutdown_default_executor`."
msgstr "Оновлено для використання :meth:`loop.shutdown_default_executor`."

msgid ""
"*debug* is ``None`` by default to respect the global debug mode settings."
msgstr ""
"*debug* за замовчуванням має значення ``None``, щоб дотримуватися глобальних "
"налаштувань режиму налагодження."

msgid "Runner context manager"
msgstr "Менеджер контексту Runner"

msgid ""
"A context manager that simplifies *multiple* async function calls in the "
"same context."
msgstr ""
"Менеджер контексту, який спрощує *кілька* викликів асинхронних функцій в "
"одному контексті."

msgid ""
"Sometimes several top-level async functions should be called in the same :"
"ref:`event loop <asyncio-event-loop>` and :class:`contextvars.Context`."
msgstr ""
"Іноді в одному :ref:`циклі подій <asyncio-event-loop>` і :class:`contextvars."
"Context` слід викликати кілька асинхронних функцій верхнього рівня."

msgid ""
"*loop_factory* could be used for overriding the loop creation. :func:"
"`asyncio.new_event_loop` is used if ``None``."
msgstr ""
"*loop_factory* можна використовувати для перевизначення створення циклу. :"
"func:`asyncio.new_event_loop` використовується, якщо ``None``."

msgid ""
"Basically, :func:`asyncio.run()` example can be rewritten with the runner "
"usage::"
msgstr ""
"По суті, приклад :func:`asyncio.run()` можна переписати з використанням "
"бігуна::"

msgid "Run a :term:`coroutine <coroutine>` *coro* in the embedded loop."
msgstr "Запустіть :term:`coroutine <coroutine>` *coro* у вбудованому циклі."

msgid "Return the coroutine's result or raise its exception."
msgstr "Повернути результат співпрограми або викликати її виключення."

msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The runner's default "
"context is used if ``None``."
msgstr ""
"Додатковий аргумент *context*, що містить лише ключове слово, дозволяє "
"вказати спеціальний :class:`contextvars.Context` для запуску *coro*. "
"Контекст програми за замовчуванням використовується, якщо ``None``."

msgid "Close the runner."
msgstr "Закрийте бігунок."

msgid ""
"Finalize asynchronous generators, shutdown default executor, close the event "
"loop and release embedded :class:`contextvars.Context`."
msgstr ""
"Завершіть асинхронні генератори, вимкніть виконавця за замовчуванням, "
"закрийте цикл подій і звільніть вбудований :class:`contextvars.Context`."

msgid "Return the event loop associated with the runner instance."
msgstr "Повертає цикл подій, пов’язаний із екземпляром бігуна."

msgid ""
":class:`Runner` uses the lazy initialization strategy, its constructor "
"doesn't initialize underlying low-level structures."
msgstr ""
":class:`Runner` використовує стратегію відкладеної ініціалізації, його "
"конструктор не ініціалізує базові структури низького рівня."

msgid ""
"Embedded *loop* and *context* are created at the :keyword:`with` body "
"entering or the first call of :meth:`run` or :meth:`get_loop`."
msgstr ""
"Вбудований *цикл* і *контекст* створюються під час введення тіла :keyword:"
"`with` або першого виклику :meth:`run` або :meth:`get_loop`."

msgid "Handling Keyboard Interruption"
msgstr "Обробка переривання клавіатури"

msgid ""
"When :const:`signal.SIGINT` is raised by :kbd:`Ctrl-C`, :exc:"
"`KeyboardInterrupt` exception is raised in the main thread by default. "
"However this doesn't work with :mod:`asyncio` because it can interrupt "
"asyncio internals and can hang the program from exiting."
msgstr ""
"Коли :const:`signal.SIGINT` викликається :kbd:`Ctrl-C`, :exc:"
"`KeyboardInterrupt` за замовчуванням викликається виняткова ситуація в "
"головному потоці. Однак це не працює з :mod:`asyncio`, оскільки це може "
"призвести до переривання внутрішніх функцій asyncio і призупинити вихід "
"програми."

msgid ""
"To mitigate this issue, :mod:`asyncio` handles :const:`signal.SIGINT` as "
"follows:"
msgstr ""
"Щоб пом’якшити цю проблему, :mod:`asyncio` обробляє :const:`signal.SIGINT` "
"наступним чином:"

msgid ""
":meth:`asyncio.Runner.run` installs a custom :const:`signal.SIGINT` handler "
"before any user code is executed and removes it when exiting from the "
"function."
msgstr ""
":meth:`asyncio.Runner.run` встановлює спеціальний обробник :const:`signal."
"SIGINT` перед виконанням будь-якого коду користувача та видаляє його під час "
"виходу з функції."

msgid ""
"The :class:`~asyncio.Runner` creates the main task for the passed coroutine "
"for its execution."
msgstr ""
":class:`~asyncio.Runner` створює основне завдання для переданої співпрограми "
"для її виконання."

msgid ""
"When :const:`signal.SIGINT` is raised by :kbd:`Ctrl-C`, the custom signal "
"handler cancels the main task by calling :meth:`asyncio.Task.cancel` which "
"raises :exc:`asyncio.CancelledError` inside the main task.  This causes the "
"Python stack to unwind, ``try/except`` and ``try/finally`` blocks can be "
"used for resource cleanup.  After the main task is cancelled, :meth:`asyncio."
"Runner.run` raises :exc:`KeyboardInterrupt`."
msgstr ""
"Коли :const:`signal.SIGINT` викликається :kbd:`Ctrl-C`, спеціальний обробник "
"сигналів скасовує основне завдання, викликаючи :meth:`asyncio.Task.cancel`, "
"що викликає :exc:`asyncio.CancelledError` всередині основного завдання. Це "
"спричиняє розгортання стека Python, блоки ``try/except`` і ``try/finally`` "
"можна використовувати для очищення ресурсу. Після скасування основного "
"завдання :meth:`asyncio.Runner.run` викликає :exc:`KeyboardInterrupt`."

msgid ""
"A user could write a tight loop which cannot be interrupted by :meth:"
"`asyncio.Task.cancel`, in which case the second following :kbd:`Ctrl-C` "
"immediately raises the :exc:`KeyboardInterrupt` without cancelling the main "
"task."
msgstr ""
"Користувач може написати щільний цикл, який не можна перервати :meth:"
"`asyncio.Task.cancel`, у цьому випадку другий наступний :kbd:`Ctrl-C` "
"негайно викликає :exc:`KeyboardInterrupt` без скасування основного завдання."
