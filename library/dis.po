# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:04+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`dis` --- Disassembler for Python bytecode"
msgstr ":mod:`dis` --- Дизасемблер для байт-коду Python"

msgid "**Source code:** :source:`Lib/dis.py`"
msgstr "**Вихідний код:** :source:`Lib/dis.py`"

msgid ""
"The :mod:`dis` module supports the analysis of CPython :term:`bytecode` by "
"disassembling it. The CPython bytecode which this module takes as an input "
"is defined in the file :file:`Include/opcode.h` and used by the compiler and "
"the interpreter."
msgstr ""
"Модуль :mod:`dis` підтримує аналіз :term:`bytecode` CPython шляхом його "
"розбирання. Байт-код CPython, який цей модуль приймає як вхідні дані, "
"визначається у файлі :file:`Include/opcode.h` і використовується "
"компілятором та інтерпретатором."

msgid ""
"Bytecode is an implementation detail of the CPython interpreter.  No "
"guarantees are made that bytecode will not be added, removed, or changed "
"between versions of Python.  Use of this module should not be considered to "
"work across Python VMs or Python releases."
msgstr ""
"Байт-код — це деталь реалізації інтерпретатора CPython. Немає гарантій, що "
"байт-код не буде додано, видалено або змінено між версіями Python. "
"Використання цього модуля не слід вважати таким, що працює на віртуальних "
"машинах Python або випусках Python."

msgid ""
"Use 2 bytes for each instruction. Previously the number of bytes varied by "
"instruction."
msgstr ""
"Використовуйте 2 байти для кожної інструкції. Раніше кількість байтів "
"змінювалася залежно від інструкції."

msgid "Example: Given the function :func:`myfunc`::"
msgstr "Приклад: Дано функцію :func:`myfunc`::"

msgid ""
"the following command can be used to display the disassembly of :func:"
"`myfunc`::"
msgstr ""

msgid "(The \"2\" is a line number)."
msgstr "(\"2\" — це номер рядка)."

msgid "Bytecode analysis"
msgstr "Аналіз байт-коду"

msgid ""
"The bytecode analysis API allows pieces of Python code to be wrapped in a :"
"class:`Bytecode` object that provides easy access to details of the compiled "
"code."
msgstr ""
"API аналізу байт-коду дозволяє обернути фрагменти коду Python в об’єкт :"
"class:`Bytecode`, який забезпечує легкий доступ до деталей скомпільованого "
"коду."

msgid ""
"Analyse the bytecode corresponding to a function, generator, asynchronous "
"generator, coroutine, method, string of source code, or a code object (as "
"returned by :func:`compile`)."
msgstr ""
"Проаналізуйте байт-код, що відповідає функції, генератору, асинхронному "
"генератору, співпрограмі, методу, рядку вихідного коду або об’єкту коду (як "
"повертає :func:`compile`)."

msgid ""
"This is a convenience wrapper around many of the functions listed below, "
"most notably :func:`get_instructions`, as iterating over a :class:`Bytecode` "
"instance yields the bytecode operations as :class:`Instruction` instances."
msgstr ""
"Це зручна обгортка для багатьох функцій, перелічених нижче, особливо :func:"
"`get_instructions`, оскільки ітерація над екземпляром :class:`Bytecode` дає "
"операції з байт-кодом як екземпляри :class:`Instruction`."

msgid ""
"If *first_line* is not ``None``, it indicates the line number that should be "
"reported for the first source line in the disassembled code.  Otherwise, the "
"source line information (if any) is taken directly from the disassembled "
"code object."
msgstr ""
"Якщо *first_line* не є ``None``, це вказує номер рядка, який має бути "
"повідомлено для першого вихідного рядка в дизассембленому коді. В іншому "
"випадку інформація про вихідний рядок (якщо така є) береться безпосередньо з "
"розібраного об’єкта коду."

msgid ""
"If *current_offset* is not ``None``, it refers to an instruction offset in "
"the disassembled code. Setting this means :meth:`.dis` will display a "
"\"current instruction\" marker against the specified opcode."
msgstr ""
"Якщо *current_offset* не є ``None``, це стосується зсуву інструкції в "
"дизассембленому коді. Якщо встановити це значення, :meth:`.dis` "
"відображатиме маркер \"поточна інструкція\" проти вказаного коду операції."

msgid ""
"Construct a :class:`Bytecode` instance from the given traceback, setting "
"*current_offset* to the instruction responsible for the exception."
msgstr ""
"Створіть екземпляр :class:`Bytecode` із заданого трасування, встановивши "
"*current_offset* для інструкції, відповідальної за виняток."

msgid "The compiled code object."
msgstr "Об’єкт скомпільованого коду."

msgid "The first source line of the code object (if available)"
msgstr "Перший вихідний рядок об'єкта коду (якщо доступний)"

msgid ""
"Return a formatted view of the bytecode operations (the same as printed by :"
"func:`dis.dis`, but returned as a multi-line string)."
msgstr ""
"Повертає відформатований вигляд операцій байт-коду (те саме, що надруковано :"
"func:`dis.dis`, але повертається як багаторядковий рядок)."

msgid ""
"Return a formatted multi-line string with detailed information about the "
"code object, like :func:`code_info`."
msgstr ""
"Повертає відформатований багаторядковий рядок із детальною інформацією про "
"об’єкт коду, наприклад :func:`code_info`."

msgid "This can now handle coroutine and asynchronous generator objects."
msgstr ""
"Тепер це може обробляти об’єкти співпрограми та асинхронного генератора."

msgid "Example::"
msgstr "Приклад::"

msgid "Analysis functions"
msgstr "Функції аналізу"

msgid ""
"The :mod:`dis` module also defines the following analysis functions that "
"convert the input directly to the desired output. They can be useful if only "
"a single operation is being performed, so the intermediate analysis object "
"isn't useful:"
msgstr ""
"Модуль :mod:`dis` також визначає наступні функції аналізу, які перетворюють "
"вхідні дані безпосередньо в бажані вивідні дані. Вони можуть бути корисними, "
"якщо виконується лише одна операція, тому проміжний об’єкт аналізу не "
"корисний:"

msgid ""
"Return a formatted multi-line string with detailed code object information "
"for the supplied function, generator, asynchronous generator, coroutine, "
"method, source code string or code object."
msgstr ""
"Повертає відформатований багаторядковий рядок із детальною інформацією про "
"об’єкт коду для наданої функції, генератора, асинхронного генератора, "
"співпрограми, методу, рядка вихідного коду чи об’єкта коду."

msgid ""
"Note that the exact contents of code info strings are highly implementation "
"dependent and they may change arbitrarily across Python VMs or Python "
"releases."
msgstr ""
"Зауважте, що точний вміст інформаційних рядків коду сильно залежить від "
"реалізації та може довільно змінюватися на різних віртуальних машинах Python "
"або випусках Python."

msgid ""
"Print detailed code object information for the supplied function, method, "
"source code string or code object to *file* (or ``sys.stdout`` if *file* is "
"not specified)."
msgstr ""
"Вивести детальну інформацію про об’єкт коду для наданої функції, методу, "
"рядка вихідного коду або об’єкта коду у *файл* (або ``sys.stdout``, якщо "
"*файл* не вказано)."

msgid ""
"This is a convenient shorthand for ``print(code_info(x), file=file)``, "
"intended for interactive exploration at the interpreter prompt."
msgstr ""
"Це зручне скорочення для ``print(code_info(x), file=file)``, призначене для "
"інтерактивного дослідження під час підказки інтерпретатора."

msgid "Added *file* parameter."
msgstr "Додано параметр *file*."

msgid ""
"Disassemble the *x* object.  *x* can denote either a module, a class, a "
"method, a function, a generator, an asynchronous generator, a coroutine, a "
"code object, a string of source code or a byte sequence of raw bytecode. For "
"a module, it disassembles all functions. For a class, it disassembles all "
"methods (including class and static methods). For a code object or sequence "
"of raw bytecode, it prints one line per bytecode instruction. It also "
"recursively disassembles nested code objects (the code of comprehensions, "
"generator expressions and nested functions, and the code used for building "
"nested classes). Strings are first compiled to code objects with the :func:"
"`compile` built-in function before being disassembled.  If no object is "
"provided, this function disassembles the last traceback."
msgstr ""
"Розберіть об'єкт *x*. *x* може позначати модуль, клас, метод, функцію, "
"генератор, асинхронний генератор, співпрограму, кодовий об’єкт, рядок "
"вихідного коду або послідовність байтів необробленого байт-коду. Для модуля "
"він розбирає всі функції. Для класу він розбирає всі методи (включаючи "
"класові та статичні методи). Для кодового об’єкта або послідовності "
"необробленого байт-коду він друкує один рядок для кожної інструкції байт-"
"коду. Він також рекурсивно розбирає вкладені об’єкти коду (код розуміння, "
"вирази генератора та вкладені функції, а також код, який використовується "
"для створення вкладених класів). Рядки спочатку компілюються для кодування "
"об’єктів за допомогою вбудованої функції :func:`compile` перед розбиранням. "
"Якщо об’єкт не надано, ця функція розбирає останню трасування."

msgid ""
"The disassembly is written as text to the supplied *file* argument if "
"provided and to ``sys.stdout`` otherwise."
msgstr ""
"Розбирання записується як текст до наданого аргументу *file*, якщо він "
"надається, та до ``sys.stdout`` інакше."

msgid ""
"The maximal depth of recursion is limited by *depth* unless it is ``None``. "
"``depth=0`` means no recursion."
msgstr ""
"Максимальна глибина рекурсії обмежена параметром *depth*, якщо не "
"встановлено ``None``. ``depth=0`` означає відсутність рекурсії."

msgid "Implemented recursive disassembling and added *depth* parameter."
msgstr "Реалізовано рекурсивне розбирання та додано параметр *depth*."

msgid ""
"Disassemble the top-of-stack function of a traceback, using the last "
"traceback if none was passed.  The instruction causing the exception is "
"indicated."
msgstr ""
"Розберіть функцію top-of-stack зворотного трасування, використовуючи останню "
"трасування, якщо жодного не було передано. Вказується інструкція, що "
"спричиняє виняток."

msgid ""
"Disassemble a code object, indicating the last instruction if *lasti* was "
"provided.  The output is divided in the following columns:"
msgstr ""
"Розберіть об’єкт коду, вказавши останню інструкцію, якщо було надано "
"*lasti*. Результат поділено на такі стовпці:"

msgid "the line number, for the first instruction of each line"
msgstr "номер рядка для першої інструкції кожного рядка"

msgid "the current instruction, indicated as ``-->``,"
msgstr "поточна інструкція, позначена як ``-->``,"

msgid "a labelled instruction, indicated with ``>>``,"
msgstr "маркована інструкція, позначена ``>>``,"

msgid "the address of the instruction,"
msgstr "адреса інструкції,"

msgid "the operation code name,"
msgstr "кодова назва операції,"

msgid "operation parameters, and"
msgstr "параметри роботи, і"

msgid "interpretation of the parameters in parentheses."
msgstr "інтерпретація параметрів у дужках."

msgid ""
"The parameter interpretation recognizes local and global variable names, "
"constant values, branch targets, and compare operators."
msgstr ""
"Інтерпретація параметрів розпізнає імена локальних і глобальних змінних, "
"постійні значення, цілі розгалужень і оператори порівняння."

msgid ""
"Return an iterator over the instructions in the supplied function, method, "
"source code string or code object."
msgstr ""
"Повертає ітератор над інструкціями в наданій функції, методі, рядку "
"вихідного коду або об’єкті коду."

msgid ""
"The iterator generates a series of :class:`Instruction` named tuples giving "
"the details of each operation in the supplied code."
msgstr ""
"Ітератор генерує ряд іменованих кортежів :class:`Instruction`, що надає "
"деталі кожної операції в наданому коді."

msgid ""
"This generator function uses the ``co_firstlineno`` and ``co_lnotab`` "
"attributes of the code object *code* to find the offsets which are starts of "
"lines in the source code.  They are generated as ``(offset, lineno)`` pairs. "
"See :source:`Objects/lnotab_notes.txt` for the ``co_lnotab`` format and how "
"to decode it."
msgstr ""
"Ця функція-генератор використовує атрибути co_firstlineno і co_lnotab "
"об'єкта коду *code* для пошуку зсувів, які є початками рядків у вихідному "
"коді. Вони генеруються як пари ``(offset, lineno)``. Перегляньте :source:"
"`Objects/lnotab_notes.txt`, щоб дізнатися про формат ``co_lnotab`` і як його "
"декодувати."

msgid "Line numbers can be decreasing. Before, they were always increasing."
msgstr "Номери рядків можуть зменшуватися. Раніше вони постійно зростали."

msgid ""
"Detect all offsets in the raw compiled bytecode string *code* which are jump "
"targets, and return a list of these offsets."
msgstr ""
"Виявлення всіх зсувів у необробленому скомпільованому рядку *code* байт-"
"коду, які є цілями переходу, і повернення списку цих зсувів."

msgid "Compute the stack effect of *opcode* with argument *oparg*."
msgstr "Обчисліть ефект стека *opcode* з аргументом *oparg*."

msgid ""
"If the code has a jump target and *jump* is ``True``, :func:`~stack_effect` "
"will return the stack effect of jumping.  If *jump* is ``False``, it will "
"return the stack effect of not jumping. And if *jump* is ``None`` (default), "
"it will return the maximal stack effect of both cases."
msgstr ""
"Якщо код має ціль переходу і *jump* має значення ``True``, :func:"
"`~stack_effect` поверне ефект стека стрибка. Якщо *jump* має значення "
"``False``, він поверне ефект стека без стрибка. І якщо *jump* має значення "
"``None`` (за замовчуванням), він поверне максимальний ефект стека в обох "
"випадках."

msgid "Added *jump* parameter."
msgstr "Додано параметр *jump*."

msgid "Python Bytecode Instructions"
msgstr "Інструкції щодо байт-коду Python"

msgid ""
"The :func:`get_instructions` function and :class:`Bytecode` class provide "
"details of bytecode instructions as :class:`Instruction` instances:"
msgstr ""
"Функція :func:`get_instructions` і клас :class:`Bytecode` надають деталі "
"інструкцій байт-коду як екземпляри :class:`Instruction`:"

msgid "Details for a bytecode operation"
msgstr "Подробиці для операції байт-коду"

msgid ""
"numeric code for operation, corresponding to the opcode values listed below "
"and the bytecode values in the :ref:`opcode_collections`."
msgstr ""
"числовий код для операції, що відповідає значенням коду операції, наведеним "
"нижче, і значенням байт-коду в :ref:`opcode_collections`."

msgid "human readable name for operation"
msgstr "зрозуміла для людини назва операції"

msgid "numeric argument to operation (if any), otherwise ``None``"
msgstr "числовий аргумент операції (якщо є), інакше ``None``"

msgid "resolved arg value (if known), otherwise same as arg"
msgstr ""

msgid "human readable description of operation argument"
msgstr ""

msgid "start index of operation within bytecode sequence"
msgstr "початковий індекс операції в послідовності байт-коду"

msgid "line started by this opcode (if any), otherwise ``None``"
msgstr "рядок починається цим кодом операції (якщо є), інакше ``None``"

msgid "``True`` if other code jumps to here, otherwise ``False``"
msgstr "``True``, якщо інший код переходить сюди, інакше ``False``"

msgid ""
"The Python compiler currently generates the following bytecode instructions."
msgstr "Наразі компілятор Python генерує наступні інструкції байт-коду."

msgid "**General instructions**"
msgstr "**Загальні інструкції**"

msgid "Do nothing code.  Used as a placeholder by the bytecode optimizer."
msgstr ""

msgid "Removes the top-of-stack (TOS) item."
msgstr "Видаляє елемент верхнього стека (TOS)."

msgid "Swaps the two top-most stack items."
msgstr ""

msgid ""
"Lifts second and third stack item one position up, moves top down to "
"position three."
msgstr ""

msgid ""
"Lifts second, third and fourth stack items one position up, moves top down "
"to position four."
msgstr ""

msgid "Duplicates the reference on top of the stack."
msgstr ""

msgid ""
"Duplicates the two references on top of the stack, leaving them in the same "
"order."
msgstr ""

msgid "**Unary operations**"
msgstr "**Унарні операції**"

msgid ""
"Unary operations take the top of the stack, apply the operation, and push "
"the result back on the stack."
msgstr ""
"Унарні операції займають вершину стека, застосовують операцію та повертають "
"результат назад у стек."

msgid "Implements ``TOS = +TOS``."
msgstr "Реалізує ``TOS = +TOS``."

msgid "Implements ``TOS = -TOS``."
msgstr "Реалізує ``TOS = -TOS``."

msgid "Implements ``TOS = not TOS``."
msgstr "Реалізує ``TOS = not TOS``."

msgid "Implements ``TOS = ~TOS``."
msgstr "Реалізує ``TOS = ~TOS``."

msgid "Implements ``TOS = iter(TOS)``."
msgstr "Реалізує ``TOS = iter(TOS)``."

msgid ""
"If ``TOS`` is a :term:`generator iterator` or :term:`coroutine` object it is "
"left as is.  Otherwise, implements ``TOS = iter(TOS)``."
msgstr ""
"Якщо ``TOS`` є об’єктом :term:`generator iterator` або :term:`coroutine`, "
"він залишається таким, як є. В іншому випадку реалізує ``TOS = iter(TOS)``."

msgid "**Binary operations**"
msgstr ""

msgid ""
"Binary operations remove the top of the stack (TOS) and the second top-most "
"stack item (TOS1) from the stack.  They perform the operation, and put the "
"result back on the stack."
msgstr ""
"Двійкові операції видаляють верхню частину стека (TOS) і другий найвищий "
"елемент стека (TOS1) зі стеку. Вони виконують операцію та повертають "
"результат у стек."

msgid "Implements ``TOS = TOS1 ** TOS``."
msgstr ""

msgid "Implements ``TOS = TOS1 * TOS``."
msgstr ""

msgid "Implements ``TOS = TOS1 @ TOS``."
msgstr ""

msgid "Implements ``TOS = TOS1 // TOS``."
msgstr ""

msgid "Implements ``TOS = TOS1 / TOS``."
msgstr ""

msgid "Implements ``TOS = TOS1 % TOS``."
msgstr ""

msgid "Implements ``TOS = TOS1 + TOS``."
msgstr ""

msgid "Implements ``TOS = TOS1 - TOS``."
msgstr ""

msgid "Implements ``TOS = TOS1[TOS]``."
msgstr "Реалізує ``TOS = TOS1[TOS]``."

msgid "Implements ``TOS = TOS1 << TOS``."
msgstr ""

msgid "Implements ``TOS = TOS1 >> TOS``."
msgstr ""

msgid "Implements ``TOS = TOS1 & TOS``."
msgstr ""

msgid "Implements ``TOS = TOS1 ^ TOS``."
msgstr ""

msgid "Implements ``TOS = TOS1 | TOS``."
msgstr ""

msgid "**In-place operations**"
msgstr ""

msgid ""
"In-place operations are like binary operations, in that they remove TOS and "
"TOS1, and push the result back on the stack, but the operation is done in-"
"place when TOS1 supports it, and the resulting TOS may be (but does not have "
"to be) the original TOS1."
msgstr ""
"Операції на місці схожі на двійкові операції, оскільки вони видаляють TOS і "
"TOS1 і повертають результат назад у стек, але операція виконується на місці, "
"коли TOS1 підтримує це, і результуючий TOS може бути (але не має бути) "
"оригінальний TOS1."

msgid "Implements in-place ``TOS = TOS1 ** TOS``."
msgstr ""

msgid "Implements in-place ``TOS = TOS1 * TOS``."
msgstr ""

msgid "Implements in-place ``TOS = TOS1 @ TOS``."
msgstr ""

msgid "Implements in-place ``TOS = TOS1 // TOS``."
msgstr ""

msgid "Implements in-place ``TOS = TOS1 / TOS``."
msgstr ""

msgid "Implements in-place ``TOS = TOS1 % TOS``."
msgstr ""

msgid "Implements in-place ``TOS = TOS1 + TOS``."
msgstr ""

msgid "Implements in-place ``TOS = TOS1 - TOS``."
msgstr ""

msgid "Implements in-place ``TOS = TOS1 << TOS``."
msgstr ""

msgid "Implements in-place ``TOS = TOS1 >> TOS``."
msgstr ""

msgid "Implements in-place ``TOS = TOS1 & TOS``."
msgstr ""

msgid "Implements in-place ``TOS = TOS1 ^ TOS``."
msgstr ""

msgid "Implements in-place ``TOS = TOS1 | TOS``."
msgstr ""

msgid "Implements ``TOS1[TOS] = TOS2``."
msgstr "Реалізує ``TOS1[TOS] = TOS2``."

msgid "Implements ``del TOS1[TOS]``."
msgstr "Реалізує ``del TOS1[TOS]``."

msgid "**Coroutine opcodes**"
msgstr "**Коди операцій співпрограми**"

msgid ""
"Implements ``TOS = get_awaitable(TOS)``, where ``get_awaitable(o)`` returns "
"``o`` if ``o`` is a coroutine object or a generator object with the "
"CO_ITERABLE_COROUTINE flag, or resolves ``o.__await__``."
msgstr ""
"Реалізує ``TOS = get_awaitable(TOS)``, де ``get_awaitable(o)`` повертає "
"``o``, якщо ``o`` є об'єктом співпрограми або об'єктом генератора з прапором "
"CO_ITERABLE_COROUTINE, або вирішує ``o.__await__``."

msgid "Implements ``TOS = TOS.__aiter__()``."
msgstr "Реалізує ``TOS = TOS.__aiter__()``."

msgid "Returning awaitable objects from ``__aiter__`` is no longer supported."
msgstr ""
"Повернення очікуваних об’єктів із ``__aiter__`` більше не підтримується."

msgid ""
"Implements ``PUSH(get_awaitable(TOS.__anext__()))``.  See ``GET_AWAITABLE`` "
"for details about ``get_awaitable``"
msgstr ""

msgid ""
"Terminates an :keyword:`async for` loop.  Handles an exception raised when "
"awaiting a next item.  If TOS is :exc:`StopAsyncIteration` pop 7 values from "
"the stack and restore the exception state using the second three of them.  "
"Otherwise re-raise the exception using the three values from the stack.  An "
"exception handler block is removed from the block stack."
msgstr ""

msgid ""
"Resolves ``__aenter__`` and ``__aexit__`` from the object on top of the "
"stack.  Pushes ``__aexit__`` and result of ``__aenter__()`` to the stack."
msgstr ""
"Вирішує ``__aenter__`` і ``__aexit__`` з об’єкта на вершині стека. Надсилає "
"``__aexit__`` і результат ``__aenter__()`` до стеку."

msgid "Creates a new frame object."
msgstr ""

msgid "**Miscellaneous opcodes**"
msgstr "**Різні коди операцій**"

msgid ""
"Implements the expression statement for the interactive mode.  TOS is "
"removed from the stack and printed.  In non-interactive mode, an expression "
"statement is terminated with :opcode:`POP_TOP`."
msgstr ""
"Реалізує оператор виразу для інтерактивного режиму. TOS видаляється зі стеку "
"та друкується. У неінтерактивному режимі оператор виразу завершується :"
"opcode:`POP_TOP`."

msgid ""
"Calls ``set.add(TOS1[-i], TOS)``.  Used to implement set comprehensions."
msgstr ""
"Викликає ``set.add(TOS1[-i], TOS)``. Використовується для реалізації "
"розуміння набору."

msgid ""
"Calls ``list.append(TOS1[-i], TOS)``.  Used to implement list comprehensions."
msgstr ""
"Викликає ``list.append(TOS1[-i], TOS)``. Використовується для реалізації "
"розуміння списку."

msgid ""
"Calls ``dict.__setitem__(TOS1[-i], TOS1, TOS)``.  Used to implement dict "
"comprehensions."
msgstr ""
"Викликає ``dict.__setitem__(TOS1[-i], TOS1, TOS)``. Використовується для "
"реалізації диктового розуміння."

msgid "Map value is TOS and map key is TOS1. Before, those were reversed."
msgstr "Значення карти – TOS, а ключ карти – TOS1. Раніше вони були змінені."

msgid ""
"For all of the :opcode:`SET_ADD`, :opcode:`LIST_APPEND` and :opcode:"
"`MAP_ADD` instructions, while the added value or key/value pair is popped "
"off, the container object remains on the stack so that it is available for "
"further iterations of the loop."
msgstr ""
"Для всіх інструкцій :opcode:`SET_ADD`, :opcode:`LIST_APPEND` і :opcode:"
"`MAP_ADD`, поки додане значення або пара ключ/значення видаляється, об’єкт-"
"контейнер залишається в стеку, тому він доступний для подальших ітерацій "
"циклу."

msgid "Returns with TOS to the caller of the function."
msgstr "Повертається з TOS до абонента функції."

msgid "Pops TOS and yields it from a :term:`generator`."
msgstr "Витягує TOS і повертає його з :term:`generator`."

msgid "Pops TOS and delegates to it as a subiterator from a :term:`generator`."
msgstr "Видає TOS і делегує йому як субітератор із :term:`generator`."

msgid ""
"Checks whether ``__annotations__`` is defined in ``locals()``, if not it is "
"set up to an empty ``dict``. This opcode is only emitted if a class or "
"module body contains :term:`variable annotations <variable annotation>` "
"statically."
msgstr ""
"Перевіряє, чи визначено ``__annotations__`` в ``locals()``, якщо ні, воно "
"встановлюється на порожній ``dict``. Цей код операції видається, лише якщо "
"тіло класу або модуля містить :term:`анотації змінних <variable annotation>` "
"статично."

msgid ""
"Loads all symbols not starting with ``'_'`` directly from the module TOS to "
"the local namespace. The module is popped after loading all names. This "
"opcode implements ``from module import *``."
msgstr ""
"Завантажує всі символи, які не починаються з ``'_'`` безпосередньо з TOS "
"модуля в локальний простір імен. Модуль відкривається після завантаження "
"всіх імен. Цей код операції реалізує ``from module import *``."

msgid ""
"Removes one block from the block stack.  Per frame, there is a stack of "
"blocks, denoting :keyword:`try` statements, and such."
msgstr ""

msgid ""
"Removes one block from the block stack. The popped block must be an "
"exception handler block, as implicitly created when entering an except "
"handler.  In addition to popping extraneous values from the frame stack, the "
"last three popped values are used to restore the exception state."
msgstr ""

msgid ""
"Re-raises the exception currently on top of the stack. If oparg is non-zero, "
"restores ``f_lasti`` of the current frame to its value when the exception "
"was raised."
msgstr ""

msgid ""
"Calls the function in position 7 on the stack with the top three items on "
"the stack as arguments. Used to implement the call ``context_manager."
"__exit__(*exc_info())`` when an exception has occurred in a :keyword:`with` "
"statement."
msgstr ""

msgid ""
"Pushes :exc:`AssertionError` onto the stack.  Used by the :keyword:`assert` "
"statement."
msgstr ""
"Поміщає :exc:`AssertionError` у стек. Використовується оператором :keyword:"
"`assert`."

msgid ""
"Pushes :func:`builtins.__build_class__` onto the stack.  It is later called "
"by :opcode:`CALL_FUNCTION` to construct a class."
msgstr ""

msgid ""
"This opcode performs several operations before a with block starts.  First, "
"it loads :meth:`~object.__exit__` from the context manager and pushes it "
"onto the stack for later use by :opcode:`WITH_EXCEPT_START`.  Then, :meth:"
"`~object.__enter__` is called, and a finally block pointing to *delta* is "
"pushed.  Finally, the result of calling the ``__enter__()`` method is pushed "
"onto the stack.  The next opcode will either ignore it (:opcode:`POP_TOP`), "
"or store it in (a) variable(s) (:opcode:`STORE_FAST`, :opcode:`STORE_NAME`, "
"or :opcode:`UNPACK_SEQUENCE`)."
msgstr ""

msgid ""
"TOS is a tuple of mapping keys, and TOS1 is the match subject.  Replace TOS "
"with a :class:`dict` formed from the items of TOS1, but without any of the "
"keys in TOS."
msgstr ""

msgid "Push ``len(TOS)`` onto the stack."
msgstr "Перемістіть ``len(TOS)`` у стек."

msgid ""
"If TOS is an instance of :class:`collections.abc.Mapping` (or, more "
"technically: if it has the :const:`Py_TPFLAGS_MAPPING` flag set in its :c:"
"member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  Otherwise, "
"push ``False``."
msgstr ""
"Якщо TOS є екземпляром :class:`collections.abc.Mapping` (або, більш "
"технічно: якщо він має прапорець :const:`Py_TPFLAGS_MAPPING`, встановлений у "
"своєму :c:member:`~PyTypeObject.tp_flags`), натисніть ``True`` в стек. В "
"іншому випадку натисніть ``False``."

msgid ""
"If TOS is an instance of :class:`collections.abc.Sequence` and is *not* an "
"instance of :class:`str`/:class:`bytes`/:class:`bytearray` (or, more "
"technically: if it has the :const:`Py_TPFLAGS_SEQUENCE` flag set in its :c:"
"member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  Otherwise, "
"push ``False``."
msgstr ""
"Якщо TOS є екземпляром :class:`collections.abc.Sequence` і *не* є "
"екземпляром :class:`str`/:class:`bytes`/:class:`bytearray` (або, більш "
"технічно: якщо він має прапорець :const:`Py_TPFLAGS_SEQUENCE`, встановлений "
"у його :c:member:`~PyTypeObject.tp_flags`), вставте ``True`` у стек. В "
"іншому випадку натисніть ``False``."

msgid ""
"TOS is a tuple of mapping keys, and TOS1 is the match subject.  If TOS1 "
"contains all of the keys in TOS, push a :class:`tuple` containing the "
"corresponding values, followed by ``True``. Otherwise, push ``None``, "
"followed by ``False``."
msgstr ""

msgid "All of the following opcodes use their arguments."
msgstr ""

msgid ""
"Implements ``name = TOS``. *namei* is the index of *name* in the attribute :"
"attr:`co_names` of the code object. The compiler tries to use :opcode:"
"`STORE_FAST` or :opcode:`STORE_GLOBAL` if possible."
msgstr ""
"Реалізує ``name = TOS``. *namei* — це індекс *name* в атрибуті :attr:"
"`co_names` об’єкта коду. Компілятор намагається використовувати :opcode:"
"`STORE_FAST` або :opcode:`STORE_GLOBAL`, якщо це можливо."

msgid ""
"Implements ``del name``, where *namei* is the index into :attr:`co_names` "
"attribute of the code object."
msgstr ""
"Реалізує ``del name``, де *namei* є індексом атрибута :attr:`co_names` "
"об’єкта коду."

msgid ""
"Unpacks TOS into *count* individual values, which are put onto the stack "
"right-to-left."
msgstr ""
"Розпаковує TOS у *count* окремі значення, які поміщаються в стек справа "
"наліво."

msgid ""
"Implements assignment with a starred target: Unpacks an iterable in TOS into "
"individual values, where the total number of values can be smaller than the "
"number of items in the iterable: one of the new values will be a list of all "
"leftover items."
msgstr ""
"Реалізує призначення з позначеною зірочкою метою: розпаковує ітерацію в TOS "
"на окремі значення, де загальна кількість значень може бути меншою за "
"кількість елементів у ітерації: одне з нових значень буде списком усіх "
"залишкових елементів."

msgid ""
"The low byte of *counts* is the number of values before the list value, the "
"high byte of *counts* the number of values after it.  The resulting values "
"are put onto the stack right-to-left."
msgstr ""
"Молодший байт *counts* — це кількість значень перед значенням списку, "
"старший байт *counts* — кількість значень після нього. Отримані значення "
"поміщаються в стек справа наліво."

msgid ""
"Implements ``TOS.name = TOS1``, where *namei* is the index of name in :attr:"
"`co_names`."
msgstr ""
"Реалізує ``TOS.name = TOS1``, де *namei* є індексом імені в :attr:`co_names`."

msgid ""
"Implements ``del TOS.name``, using *namei* as index into :attr:`co_names`."
msgstr ""
"Реалізує ``del TOS.name``, використовуючи *namei* як індекс у :attr:"
"`co_names`."

msgid "Works as :opcode:`STORE_NAME`, but stores the name as a global."
msgstr "Працює як :opcode:`STORE_NAME`, але зберігає назву як глобальну."

msgid "Works as :opcode:`DELETE_NAME`, but deletes a global name."
msgstr "Працює як :opcode:`DELETE_NAME`, але видаляє глобальне ім’я."

msgid "Pushes ``co_consts[consti]`` onto the stack."
msgstr "Поміщає ``co_consts[consti]`` в стек."

msgid "Pushes the value associated with ``co_names[namei]`` onto the stack."
msgstr "Поміщає значення, пов’язане з ``co_names[namei]``, у стек."

msgid ""
"Creates a tuple consuming *count* items from the stack, and pushes the "
"resulting tuple onto the stack."
msgstr ""
"Створює кортеж, який споживає *кількість* елементів зі стеку, і поміщає "
"отриманий кортеж у стек."

msgid "Works as :opcode:`BUILD_TUPLE`, but creates a list."
msgstr "Працює як :opcode:`BUILD_TUPLE`, але створює список."

msgid "Works as :opcode:`BUILD_TUPLE`, but creates a set."
msgstr "Працює як :opcode:`BUILD_TUPLE`, але створює набір."

msgid ""
"Pushes a new dictionary object onto the stack.  Pops ``2 * count`` items so "
"that the dictionary holds *count* entries: ``{..., TOS3: TOS2, TOS1: TOS}``."
msgstr ""
"Поміщає новий об’єкт словника в стек. Показує ``2 * count`` елементи, щоб "
"словник містив *count* записи: ``{..., TOS3: TOS2, TOS1: TOS}``."

msgid ""
"The dictionary is created from stack items instead of creating an empty "
"dictionary pre-sized to hold *count* items."
msgstr ""
"Словник створюється з елементів стека замість створення порожнього словника "
"попереднього розміру для *кількості* елементів."

msgid ""
"The version of :opcode:`BUILD_MAP` specialized for constant keys. Pops the "
"top element on the stack which contains a tuple of keys, then starting from "
"``TOS1``, pops *count* values to form values in the built dictionary."
msgstr ""
"Версія :opcode:`BUILD_MAP` спеціалізована на постійних ключах. Висуває "
"верхній елемент у стеку, який містить кортеж ключів, потім, починаючи з "
"``TOS1``, витягує значення *count* для формування значень у створеному "
"словнику."

msgid ""
"Concatenates *count* strings from the stack and pushes the resulting string "
"onto the stack."
msgstr "З’єднує *count* рядки зі стеку та надихає отриманий рядок у стек."

msgid ""
"Pops a list from the stack and pushes a tuple containing the same values."
msgstr ""
"Витягує список зі стеку та надсилає кортеж, що містить однакові значення."

msgid "Calls ``list.extend(TOS1[-i], TOS)``.  Used to build lists."
msgstr ""
"Викликає ``list.extend(TOS1[-i], TOS)``. Використовується для створення "
"списків."

msgid "Calls ``set.update(TOS1[-i], TOS)``.  Used to build sets."
msgstr ""
"Викликає ``set.update(TOS1[-i], TOS)``. Використовується для складання "
"наборів."

msgid "Calls ``dict.update(TOS1[-i], TOS)``.  Used to build dicts."
msgstr ""
"Викликає ``dict.update(TOS1[-i], TOS)``. Використовується для побудови dicts."

msgid "Like :opcode:`DICT_UPDATE` but raises an exception for duplicate keys."
msgstr ""
"Подібно до :opcode:`DICT_UPDATE`, але створює виняток для дублікатів ключів."

msgid "Replaces TOS with ``getattr(TOS, co_names[namei])``."
msgstr "Замінює TOS на ``getattr(TOS, co_names[namei])``."

msgid ""
"Performs a Boolean operation.  The operation name can be found in "
"``cmp_op[opname]``."
msgstr ""
"Виконує логічні операції. Ім'я операції можна знайти в ``cmp_op[opname]``."

msgid "Performs ``is`` comparison, or ``is not`` if ``invert`` is 1."
msgstr "Виконує порівняння ``is`` або ``is not``, якщо ``invert`` дорівнює 1."

msgid "Performs ``in`` comparison, or ``not in`` if ``invert`` is 1."
msgstr "Виконує порівняння ``in`` або ``not in``, якщо ``invert`` дорівнює 1."

msgid ""
"Imports the module ``co_names[namei]``.  TOS and TOS1 are popped and provide "
"the *fromlist* and *level* arguments of :func:`__import__`.  The module "
"object is pushed onto the stack.  The current namespace is not affected: for "
"a proper import statement, a subsequent :opcode:`STORE_FAST` instruction "
"modifies the namespace."
msgstr ""
"Імпортує модуль ``co_names[namei]``. TOS і TOS1 витягуються та надають "
"аргументи *fromlist* і *level* :func:`__import__`. Об’єкт модуля поміщається "
"в стек. Поточний простір імен не впливає: для правильного оператора імпорту "
"наступна інструкція :opcode:`STORE_FAST` змінює простір імен."

msgid ""
"Loads the attribute ``co_names[namei]`` from the module found in TOS. The "
"resulting object is pushed onto the stack, to be subsequently stored by a :"
"opcode:`STORE_FAST` instruction."
msgstr ""
"Завантажує атрибут ``co_names[namei]`` з модуля, знайденого в TOS. Отриманий "
"об’єкт поміщається в стек, щоб згодом зберігатися за допомогою інструкції :"
"opcode:`STORE_FAST`."

msgid "Increments bytecode counter by *delta*."
msgstr "Збільшує лічильник байт-коду на *delta*."

msgid "If TOS is true, sets the bytecode counter to *target*.  TOS is popped."
msgstr ""

msgid "If TOS is false, sets the bytecode counter to *target*.  TOS is popped."
msgstr ""

msgid ""
"Tests whether the second value on the stack is an exception matching TOS, "
"and jumps if it is not. Pops two values from the stack."
msgstr ""

msgid ""
"If TOS is true, sets the bytecode counter to *target* and leaves TOS on the "
"stack.  Otherwise (TOS is false), TOS is popped."
msgstr ""

msgid ""
"If TOS is false, sets the bytecode counter to *target* and leaves TOS on the "
"stack.  Otherwise (TOS is true), TOS is popped."
msgstr ""

msgid "Set bytecode counter to *target*."
msgstr ""

msgid ""
"TOS is an :term:`iterator`.  Call its :meth:`~iterator.__next__` method.  If "
"this yields a new value, push it on the stack (leaving the iterator below "
"it).  If the iterator indicates it is exhausted, TOS is popped, and the byte "
"code counter is incremented by *delta*."
msgstr ""
"TOS є :term:`iterator`. Викличте його метод :meth:`~iterator.__next__`. Якщо "
"це дає нове значення, помістіть його в стек (залишаючи ітератор під ним). "
"Якщо ітератор вказує, що його вичерпано, TOS виривається, а лічильник байт-"
"коду збільшується на *delta*."

msgid "Loads the global named ``co_names[namei]`` onto the stack."
msgstr ""

msgid ""
"Pushes a try block from a try-finally or try-except clause onto the block "
"stack.  *delta* points to the finally block or the first except block."
msgstr ""

msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack."
msgstr "Надсилає посилання на локальні ``co_var_names[var_num]`` у стек."

msgid "Stores TOS into the local ``co_varnames[var_num]``."
msgstr "Зберігає TOS у локальному ``co_varnames[var_num]``."

msgid "Deletes local ``co_varnames[var_num]``."
msgstr "Видаляє локальні ``co_var_names[var_num]``."

msgid ""
"Pushes a reference to the cell contained in slot *i* of the cell and free "
"variable storage.  The name of the variable is ``co_cellvars[i]`` if *i* is "
"less than the length of *co_cellvars*.  Otherwise it is ``co_freevars[i - "
"len(co_cellvars)]``."
msgstr ""

msgid ""
"Loads the cell contained in slot *i* of the cell and free variable storage. "
"Pushes a reference to the object the cell contains on the stack."
msgstr ""

msgid ""
"Much like :opcode:`LOAD_DEREF` but first checks the locals dictionary before "
"consulting the cell.  This is used for loading free variables in class "
"bodies."
msgstr ""
"Подібно до :opcode:`LOAD_DEREF`, але спочатку перевіряє локальний словник, "
"перш ніж звертатися до клітинки. Це використовується для завантаження "
"вільних змінних у тілах класів."

msgid ""
"Stores TOS into the cell contained in slot *i* of the cell and free variable "
"storage."
msgstr ""

msgid ""
"Empties the cell contained in slot *i* of the cell and free variable "
"storage. Used by the :keyword:`del` statement."
msgstr ""

msgid ""
"Raises an exception using one of the 3 forms of the ``raise`` statement, "
"depending on the value of *argc*:"
msgstr ""
"Створює виняток, використовуючи одну з 3 форм оператора ``raise``, залежно "
"від значення *argc*:"

msgid "0: ``raise`` (re-raise previous exception)"
msgstr "0: ``raise`` (повторно підняти попередній виняток)"

msgid "1: ``raise TOS`` (raise exception instance or type at ``TOS``)"
msgstr "1: ``підняти TOS`` (підвищити екземпляр винятку або ввести в ``TOS``)"

msgid ""
"2: ``raise TOS1 from TOS`` (raise exception instance or type at ``TOS1`` "
"with ``__cause__`` set to ``TOS``)"
msgstr ""
"2: ``підняти TOS1 з TOS`` (підняти екземпляр винятку або ввести в ``TOS1`` з "
"``__cause__``, встановленим на ``TOS``)"

msgid ""
"Calls a callable object with positional arguments. *argc* indicates the "
"number of positional arguments. The top of the stack contains positional "
"arguments, with the right-most argument on top.  Below the arguments is a "
"callable object to call. ``CALL_FUNCTION`` pops all arguments and the "
"callable object off the stack, calls the callable object with those "
"arguments, and pushes the return value returned by the callable object."
msgstr ""

msgid "This opcode is used only for calls with positional arguments."
msgstr ""

msgid ""
"Calls a callable object with positional (if any) and keyword arguments. "
"*argc* indicates the total number of positional and keyword arguments. The "
"top element on the stack contains a tuple with the names of the keyword "
"arguments, which must be strings. Below that are the values for the keyword "
"arguments, in the order corresponding to the tuple. Below that are "
"positional arguments, with the right-most parameter on top.  Below the "
"arguments is a callable object to call. ``CALL_FUNCTION_KW`` pops all "
"arguments and the callable object off the stack, calls the callable object "
"with those arguments, and pushes the return value returned by the callable "
"object."
msgstr ""

msgid ""
"Keyword arguments are packed in a tuple instead of a dictionary, *argc* "
"indicates the total number of arguments."
msgstr ""

msgid ""
"Calls a callable object with variable set of positional and keyword "
"arguments.  If the lowest bit of *flags* is set, the top of the stack "
"contains a mapping object containing additional keyword arguments. Before "
"the callable is called, the mapping object and iterable object are each "
"\"unpacked\" and their contents passed in as keyword and positional "
"arguments respectively. ``CALL_FUNCTION_EX`` pops all arguments and the "
"callable object off the stack, calls the callable object with those "
"arguments, and pushes the return value returned by the callable object."
msgstr ""
"Викликає викликаний об’єкт зі змінним набором позиційних і ключових "
"аргументів. Якщо встановлено найнижчий біт *flags*, верхня частина стека "
"містить об’єкт відображення, що містить додаткові аргументи ключового слова. "
"Перед викликом викликаного об’єкта відображення та ітерованого об’єкта кожен "
"\"розпаковується\", а їхній вміст передається як ключове слово та позиційний "
"аргумент відповідно. ``CALL_FUNCTION_EX`` видаляє зі стеку всі аргументи та "
"об’єкт, який викликається, викликає об’єкт, який викликається, з цими "
"аргументами та надсилає значення, яке повертає об’єкт, який викликається."

msgid ""
"Loads a method named ``co_names[namei]`` from the TOS object. TOS is popped. "
"This bytecode distinguishes two cases: if TOS has a method with the correct "
"name, the bytecode pushes the unbound method and TOS. TOS will be used as "
"the first argument (``self``) by :opcode:`CALL_METHOD` when calling the "
"unbound method. Otherwise, ``NULL`` and the object return by the attribute "
"lookup are pushed."
msgstr ""

msgid ""
"Calls a method.  *argc* is the number of positional arguments. Keyword "
"arguments are not supported.  This opcode is designed to be used with :"
"opcode:`LOAD_METHOD`.  Positional arguments are on top of the stack. Below "
"them, the two items described in :opcode:`LOAD_METHOD` are on the stack "
"(either ``self`` and an unbound method object or ``NULL`` and an arbitrary "
"callable). All of them are popped and the return value is pushed."
msgstr ""

msgid ""
"Pushes a new function object on the stack.  From bottom to top, the consumed "
"stack must consist of values if the argument carries a specified flag value"
msgstr ""
"Поміщає новий функціональний об’єкт у стек. Знизу вгору споживаний стек "
"повинен складатися зі значень, якщо аргумент містить вказане значення прапора"

msgid ""
"``0x01`` a tuple of default values for positional-only and positional-or-"
"keyword parameters in positional order"
msgstr ""
"``0x01`` кортеж значень за замовчуванням для позиційних параметрів і "
"параметрів позиційного або ключового слова в позиційному порядку"

msgid "``0x02`` a dictionary of keyword-only parameters' default values"
msgstr ""
"``0x02`` словник значень за замовчуванням параметрів лише ключових слів"

msgid "``0x04`` a tuple of strings containing parameters' annotations"
msgstr "``0x04`` кортеж рядків, що містять анотації параметрів"

msgid "``0x08`` a tuple containing cells for free variables, making a closure"
msgstr ""
"``0x08`` кортеж, що містить комірки для вільних змінних, створюючи закриття"

msgid "the code associated with the function (at TOS1)"
msgstr "код, пов’язаний із функцією (в TOS1)"

msgid "the :term:`qualified name` of the function (at TOS)"
msgstr ":term:`qualified name` функції (у TOS)"

msgid "Flag value ``0x04`` is a tuple of strings instead of dictionary"
msgstr "Значення прапора ``0x04`` є кортежем рядків замість словника"

msgid ""
"Pushes a slice object on the stack.  *argc* must be 2 or 3.  If it is 2, "
"``slice(TOS1, TOS)`` is pushed; if it is 3, ``slice(TOS2, TOS1, TOS)`` is "
"pushed. See the :func:`slice` built-in function for more information."
msgstr ""
"Штовхає об’єкт-скибочку на стек. *argc* має бути 2 або 3. Якщо воно дорівнює "
"2, надсилається ``slice(TOS1, TOS)``; якщо він дорівнює 3, надсилається "
"``slice(TOS2, TOS1, TOS)``. Дивіться вбудовану функцію :func:`slice` для "
"отримання додаткової інформації."

msgid ""
"Prefixes any opcode which has an argument too big to fit into the default "
"one byte. *ext* holds an additional byte which act as higher bits in the "
"argument. For each opcode, at most three prefixal ``EXTENDED_ARG`` are "
"allowed, forming an argument from two-byte to four-byte."
msgstr ""
"Додає префікс до будь-якого коду операції, який має занадто великий "
"аргумент, щоб поміститися в стандартний один байт. *ext* містить додатковий "
"байт, який діє як старші біти в аргументі. Для кожного коду операції "
"дозволено не більше трьох префіксів ``EXTENDED_ARG``, які утворюють аргумент "
"розміром від двох до чотирьох байтів."

msgid ""
"Used for implementing formatted literal strings (f-strings).  Pops an "
"optional *fmt_spec* from the stack, then a required *value*. *flags* is "
"interpreted as follows:"
msgstr ""
"Використовується для реалізації форматованих літеральних рядків (f-рядків). "
"Витягує необов’язковий *fmt_spec* зі стеку, а потім обов’язкове *значення*. "
"*flags* інтерпретується таким чином:"

msgid "``(flags & 0x03) == 0x00``: *value* is formatted as-is."
msgstr "``(flags & 0x03) == 0x00``: *значення* відформатовано як є."

msgid ""
"``(flags & 0x03) == 0x01``: call :func:`str` on *value* before formatting it."
msgstr ""
"``(flags & 0x03) == 0x01``: виклик :func:`str` для *значення* перед його "
"форматуванням."

msgid ""
"``(flags & 0x03) == 0x02``: call :func:`repr` on *value* before formatting "
"it."
msgstr ""
"``(flags & 0x03) == 0x02``: виклик :func:`repr` для *значення* перед його "
"форматуванням."

msgid ""
"``(flags & 0x03) == 0x03``: call :func:`ascii` on *value* before formatting "
"it."
msgstr ""
"``(flags & 0x03) == 0x03``: виклик :func:`ascii` для *значення* перед його "
"форматуванням."

msgid ""
"``(flags & 0x04) == 0x04``: pop *fmt_spec* from the stack and use it, else "
"use an empty *fmt_spec*."
msgstr ""
"``(flags & 0x04) == 0x04``: витягніть *fmt_spec* зі стеку та використовуйте "
"його, інакше використовуйте порожній *fmt_spec*."

msgid ""
"Formatting is performed using :c:func:`PyObject_Format`.  The result is "
"pushed on the stack."
msgstr ""
"Форматування виконується за допомогою :c:func:`PyObject_Format`. Результат "
"поміщається в стек."

msgid ""
"TOS is a tuple of keyword attribute names, TOS1 is the class being matched "
"against, and TOS2 is the match subject.  *count* is the number of positional "
"sub-patterns."
msgstr ""
"TOS — це кортеж імен атрибутів ключових слів, TOS1 — клас, з яким "
"зіставляється, а TOS2 — предмет відповідності. *count* — кількість "
"позиційних підшаблонів."

msgid ""
"Pop TOS.  If TOS2 is an instance of TOS1 and has the positional and keyword "
"attributes required by *count* and TOS, set TOS to ``True`` and TOS1 to a "
"tuple of extracted attributes.  Otherwise, set TOS to ``False``."
msgstr ""

msgid ""
"Pops TOS. The ``kind`` operand corresponds to the type of generator or "
"coroutine. The legal kinds are 0 for generator, 1 for coroutine, and 2 for "
"async generator."
msgstr ""

msgid ""
"Lift the top *count* stack items one position up, and move TOS down to "
"position *count*."
msgstr ""

msgid ""
"This is not really an opcode.  It identifies the dividing line between "
"opcodes which don't use their argument and those that do (``< "
"HAVE_ARGUMENT`` and ``>= HAVE_ARGUMENT``, respectively)."
msgstr ""
"Це насправді не код операції. Він визначає лінію розмежування між кодами "
"операцій, які не використовують свій аргумент, і тими, які використовують "
"(``< HAVE_ARGUMENT`` and ``>= HAVE_ARGUMENT``, відповідно)."

msgid ""
"Now every instruction has an argument, but opcodes ``< HAVE_ARGUMENT`` "
"ignore it. Before, only opcodes ``>= HAVE_ARGUMENT`` had an argument."
msgstr ""
"Тепер кожна інструкція має аргумент, але коди операцій ``< HAVE_ARGUMENT`` "
"ignore it. Before, only opcodes ``> = HAVE_ARGUMENT`` мали аргумент."

msgid "Opcode collections"
msgstr "Колекції кодів операцій"

msgid ""
"These collections are provided for automatic introspection of bytecode "
"instructions:"
msgstr "Ці колекції надаються для автоматичного аналізу інструкцій байт-коду:"

msgid "Sequence of operation names, indexable using the bytecode."
msgstr "Послідовність імен операцій, індексованих за допомогою байт-коду."

msgid "Dictionary mapping operation names to bytecodes."
msgstr "Словник зіставляє назви операцій із байт-кодами."

msgid "Sequence of all compare operation names."
msgstr "Послідовність імен усіх операцій порівняння."

msgid "Sequence of bytecodes that access a constant."
msgstr "Послідовність байт-кодів, які звертаються до константи."

msgid ""
"Sequence of bytecodes that access a free variable (note that 'free' in this "
"context refers to names in the current scope that are referenced by inner "
"scopes or names in outer scopes that are referenced from this scope.  It "
"does *not* include references to global or builtin scopes)."
msgstr ""
"Послідовність байт-кодів, які мають доступ до вільної змінної (зауважте, що "
"\"вільний\" у цьому контексті стосується імен у поточній області, на які "
"посилаються внутрішні області, або імен у зовнішніх областях, на які "
"посилається ця область. Він *не* включає посилання на глобальні або "
"вбудовані області)."

msgid "Sequence of bytecodes that access an attribute by name."
msgstr "Послідовність байт-кодів, які звертаються до атрибута за назвою."

msgid "Sequence of bytecodes that have a relative jump target."
msgstr "Послідовність байт-кодів, які мають відносну ціль переходу."

msgid "Sequence of bytecodes that have an absolute jump target."
msgstr "Послідовність байт-кодів, які мають абсолютну ціль переходу."

msgid "Sequence of bytecodes that access a local variable."
msgstr "Послідовність байт-кодів, які звертаються до локальної змінної."

msgid "Sequence of bytecodes of Boolean operations."
msgstr "Послідовність байт-кодів булевих операцій."
