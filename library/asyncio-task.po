# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-16 06:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Coroutines and Tasks"
msgstr "Співпрограми та завдання"

msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""
"У цьому розділі описано асинхронні API високого рівня для роботи з "
"співпрограмами та завданнями."

msgid "Coroutines"
msgstr "Співпрограми"

msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code prints \"hello\", waits 1 second, and then prints \"world\"::"
msgstr ""
":term:`Coroutines <coroutine>`, оголошений із синтаксисом async/await, є "
"кращим способом написання асинхронних програм. Наприклад, наступний фрагмент "
"коду друкує \"hello\", чекає 1 секунду, а потім друкує \"world\"::"

msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr "Зауважте, що простий виклик співпрограми не запланує її виконання:"

msgid "To actually run a coroutine, asyncio provides three main mechanisms:"
msgstr ""
"Щоб фактично запустити співпрограму, asyncio надає три основні механізми:"

msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ""
"Функція :func:`asyncio.run` для запуску функції точки входу верхнього рівня "
"\"main()\" (див. приклад вище)."

msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"Очікування співпрограми. Наступний фрагмент коду надрукує \"привіт\" після "
"очікування 1 секунду, а потім надрукує \"світ\" після очікування *ще* 2 "
"секунди::"

msgid "Expected output::"
msgstr "Очікуваний результат::"

msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"Функція :func:`asyncio.create_task` для одночасного запуску співпрограм як "
"asyncio :class:`Tasks <Task>`."

msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr ""
"Давайте змінимо наведений вище приклад і запустимо дві співпрограми "
"``say_after`` *одночасно*::"

msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""
"Зауважте, що очікуваний вихід тепер показує, що фрагмент працює на 1 секунду "
"швидше, ніж раніше:"

msgid "Awaitables"
msgstr "очікування"

msgid ""
"We say that an object is an **awaitable** object if it can be used in an :"
"keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"Ми кажемо, що об’єкт є **очікуваним** об’єктом, якщо його можна "
"використовувати у виразі :keyword:`await`. Багато асинхронних API розроблено "
"для прийняття очікуваних."

msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"Існує три основних типи *очікуваних* об’єктів: **співпрограми**, "
"**Завдання** та **Ф’ючерси**."

msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr ""
"Співпрограми Python є *очікуваними*, тому їх можна очікувати від інших "
"співпрограм:"

msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr ""
"У цій документації термін \"співпрограма\" може використовуватися для двох "
"тісно пов’язаних понять:"

msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "*співпрограма*: функція :keyword:`async def`;"

msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr ""
"*об’єкт співпрограми*: об’єкт, повернутий викликом *функції співпрограми*."

msgid ""
"asyncio also supports legacy :ref:`generator-based "
"<asyncio_generator_based_coro>` coroutines."
msgstr ""

msgid "Tasks"
msgstr "завдання"

msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr "*Завдання* використовуються для *одночасного* планування співпрограм."

msgid ""
"When a coroutine is wrapped into a *Task* with functions like :func:`asyncio."
"create_task` the coroutine is automatically scheduled to run soon::"
msgstr ""
"Коли співпрограму загорнуто в *Task* із такими функціями, як :func:`asyncio."
"create_task`, співпрограма автоматично планується для незабаром:"

msgid "Futures"
msgstr "Ф'ючерси"

msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
":class:`Future` — це спеціальний **низькорівневий** очікуваний об’єкт, який "
"представляє **кінцевий результат** асинхронної операції."

msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"Коли об’єкт Future *очікується*, це означає, що співпрограма чекатиме, поки "
"Future не буде дозволено в іншому місці."

msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr ""
"Майбутні об’єкти в asyncio потрібні для того, щоб код на основі зворотного "
"виклику використовувався з async/await."

msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr ""
"Зазвичай **немає необхідності** створювати об’єкти Future на рівні програми."

msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr ""
"Майбутні об’єкти, іноді доступні бібліотеками та деякими асинхронними API, "
"можна очікувати:"

msgid ""
"A good example of a low-level function that returns a Future object is :meth:"
"`loop.run_in_executor`."
msgstr ""
"Хорошим прикладом функції низького рівня, яка повертає об’єкт Future, є :"
"meth:`loop.run_in_executor`."

msgid "Running an asyncio Program"
msgstr ""

msgid "Execute the :term:`coroutine` *coro* and return the result."
msgstr ""

msgid ""
"This function runs the passed coroutine, taking care of managing the asyncio "
"event loop, *finalizing asynchronous generators*, and closing the threadpool."
msgstr ""

msgid ""
"This function cannot be called when another asyncio event loop is running in "
"the same thread."
msgstr ""

msgid "If *debug* is ``True``, the event loop will be run in debug mode."
msgstr ""

msgid ""
"This function always creates a new event loop and closes it at the end.  It "
"should be used as a main entry point for asyncio programs, and should "
"ideally only be called once."
msgstr ""

msgid "Example::"
msgstr "Приклад::"

msgid "Updated to use :meth:`loop.shutdown_default_executor`."
msgstr ""

msgid ""
"The source code for ``asyncio.run()`` can be found in :source:`Lib/asyncio/"
"runners.py`."
msgstr ""

msgid "Creating Tasks"
msgstr "Створення завдань"

msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"Загорніть *coro* :ref:`coroutine <coroutine>` в :class:`Task` і заплануйте "
"його виконання. Повернути об’єкт Task."

msgid ""
"If *name* is not ``None``, it is set as the name of the task using :meth:"
"`Task.set_name`."
msgstr ""
"Якщо *name* не є ``None``, воно встановлюється як назва завдання за "
"допомогою :meth:`Task.set_name`."

msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, :exc:"
"`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"Завдання виконується в циклі, який повертає :func:`get_running_loop`, :exc:"
"`RuntimeError` виникає, якщо в поточному потоці немає запущеного циклу."

msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage-collected at "
"any time, even before it's done. For reliable \"fire-and-forget\" background "
"tasks, gather them in a collection::"
msgstr ""
"Збережіть посилання на результат цієї функції, щоб уникнути зникнення "
"завдання під час виконання. Цикл подій зберігає лише слабкі посилання на "
"завдання. Завдання, яке ніде не згадується, може бути зібрано в будь-який "
"час, навіть до того, як воно буде виконане. Для надійних фонових завдань "
"типу \"запусти й забудь\" зберіть їх у колекцію:"

msgid "Added the *name* parameter."
msgstr "Додано параметр *name*."

msgid "Sleeping"
msgstr "спить"

msgid "Block for *delay* seconds."
msgstr "Блокувати на *затримку* секунд."

msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""
"Якщо надано *результат*, він повертається абоненту після завершення "
"співпрограми."

msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr ""
"``sleep()`` завжди призупиняє поточне завдання, дозволяючи виконувати інші "
"завдання."

msgid ""
"Setting the delay to 0 provides an optimized path to allow other tasks to "
"run. This can be used by long-running functions to avoid blocking the event "
"loop for the full duration of the function call."
msgstr ""
"Встановлення затримки на 0 забезпечує оптимізований шлях для виконання інших "
"завдань. Це може бути використано функціями, які довго виконуються, щоб "
"уникнути блокування циклу подій протягом повної тривалості виклику функції."

msgid ""
"The ``loop`` parameter.  This function has been implicitly getting the "
"current running loop since 3.7.  See :ref:`What's New in 3.10's Removed "
"section <whatsnew310-removed>` for more information."
msgstr ""

msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr ""
"Приклад співпрограми, що відображає поточну дату кожну секунду протягом 5 "
"секунд:"

msgid "Removed the *loop* parameter."
msgstr "Видалено параметр *loop*."

msgid "Running Tasks Concurrently"
msgstr "Одночасне виконання завдань"

msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"Запустіть :ref:`waitable objects <asyncio-awaitables>` у послідовності *aws* "
"*одночасно*."

msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr ""
"Якщо будь-який awaitable у *aws* є співпрограмою, він автоматично "
"запланований як завдання."

msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"Якщо всі очікування виконано успішно, результатом буде зведений список "
"повернутих значень. Порядок значень результатів відповідає порядку "
"очікуваних значень у *aws*."

msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"Якщо *return_exceptions* має значення ``False`` (за замовчуванням), перший "
"викликаний виняток негайно поширюється на завдання, яке очікує на "
"``gather()``. Інші очікування в послідовності *aws* **не будуть скасовані** "
"і продовжуватимуть працювати."

msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"Якщо *return_exceptions* має значення ``True``, винятки обробляються так "
"само, як успішні результати, і агрегуються в списку результатів."

msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"Якщо ``gather()`` *скасовано*, усі надіслані очікування (які ще не "
"завершені) також *скасуються*."

msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"Якщо будь-яке завдання або майбутнє з послідовності *aws* *скасовано*, воно "
"розглядається як викликане :exc:`CancelledError` -- у цьому випадку виклик "
"``gather()`` **не** скасовується . Це робиться для того, щоб запобігти "
"скасуванню одного поданого Завдання/Майбутнього, що спричинить скасування "
"інших Завдань/Ф’ючерсів."

msgid ""
"If *return_exceptions* is False, cancelling gather() after it has been "
"marked done won't cancel any submitted awaitables. For instance, gather can "
"be marked done after propagating an exception to the caller, therefore, "
"calling ``gather.cancel()`` after catching an exception (raised by one of "
"the awaitables) from gather won't cancel any other awaitables."
msgstr ""
"Якщо *return_exceptions* має значення False, скасування gather() після того, "
"як його було позначено як виконане, не скасує жодних надісланих очікувань. "
"Наприклад, gather можна позначити як виконане після передачі винятку "
"викликаючому, отже, виклик ``gather.cancel()`` після перехоплення винятку "
"(викликаного одним із очікуваних) від gather не скасує жодних інших "
"очікуваних."

msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""
"Якщо сам *gather* скасовано, скасування поширюється незалежно від "
"*return_exceptions*."

msgid ""
"Deprecation warning is emitted if no positional arguments are provided or "
"not all positional arguments are Future-like objects and there is no running "
"event loop."
msgstr ""
"Якщо не надано позиційних аргументів або не всі позиційні аргументи є Future-"
"подібними об’єктами, і немає запущеного циклу подій, видається попередження "
"про застаріле."

msgid "Shielding From Cancellation"
msgstr "Захист від скасування"

msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being :meth:"
"`cancelled <Task.cancel>`."
msgstr ""
"Захист :ref:`очікуваного об’єкта <asyncio-awaitables>` від :meth:`скасування "
"<Task.cancel>`."

msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr "Якщо *aw* є співпрограмою, вона автоматично запланована як завдання."

msgid "The statement::"
msgstr "Заява::"

msgid "is equivalent to::"
msgstr "еквівалентно::"

msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a :exc:"
"`CancelledError`."
msgstr ""
"*за винятком* того, що якщо співпрограму, яка містить його, скасовується, "
"Завдання, що виконується в ``something()``, не скасовується. З точки зору "
"``something()``, скасування не відбулося. Хоча його виклик все ще скасовано, "
"тому вираз \"чекати\" все ще викликає :exc:`CancelledError`."

msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"Якщо ``something()`` скасовано іншими засобами (тобто зсередини), це також "
"скасує ``shield()``."

msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"Якщо потрібно повністю ігнорувати скасування (не рекомендовано), функцію "
"``shield()`` слід поєднати з реченням try/except, як показано нижче:"

msgid ""
"Deprecation warning is emitted if *aw* is not Future-like object and there "
"is no running event loop."
msgstr ""
"Якщо *aw* не є Future-подібним об’єктом і немає запущеного циклу подій, "
"видається попередження про застаріння."

msgid "Timeouts"
msgstr "Тайм-аути"

msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr ""
"Зачекайте, поки *aw* :ref:`awaitable <asyncio-awaitables>` завершиться з "
"тайм-аутом."

msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* може бути або ``None``, або числом секунд для очікування з "
"плаваючою точкою або int. Якщо *timeout* має значення ``None``, блокуйте до "
"завершення майбутнього."

msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`asyncio."
"TimeoutError`."
msgstr ""

msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in :func:"
"`shield`."
msgstr ""
"Щоб уникнути завдання :meth:`скасування <Task.cancel>`, загорніть його в :"
"func:`shield`."

msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*. If an exception happens during "
"cancellation, it is propagated."
msgstr ""
"Функція чекатиме, доки майбутнє фактично не буде скасовано, тому загальний "
"час очікування може перевищити *тайм-аут*. Якщо під час скасування виникає "
"виняток, він поширюється."

msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "Якщо очікування скасовується, майбутнє *aw* також скасовується."

msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`asyncio.TimeoutError` immediately."
msgstr ""

msgid "Waiting Primitives"
msgstr "Очікування примітивів"

msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently and block until the condition specified by *return_when*."
msgstr ""

msgid "The *aws* iterable must not be empty."
msgstr "Ітерація *aws* не має бути порожньою."

msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Повертає два набори Tasks/Futures: ``(done, pending)``."

msgid "Usage::"
msgstr "Використання::"

msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr ""
"*timeout* (float або int), якщо вказано, можна використовувати для керування "
"максимальною кількістю секунд очікування перед поверненням."

msgid ""
"Note that this function does not raise :exc:`asyncio.TimeoutError`. Futures "
"or Tasks that aren't done when the timeout occurs are simply returned in the "
"second set."
msgstr ""

msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* вказує, коли ця функція має повернутися. Це має бути одна з "
"таких констант:"

msgid "Constant"
msgstr "Постійний"

msgid "Description"
msgstr "опис"

msgid ":const:`FIRST_COMPLETED`"
msgstr ":const:`FIRST_COMPLETED`"

msgid "The function will return when any future finishes or is cancelled."
msgstr ""
"Функція повернеться, коли будь-який майбутній завершиться або буде скасовано."

msgid ":const:`FIRST_EXCEPTION`"
msgstr ":const:`FIRST_EXCEPTION`"

msgid ""
"The function will return when any future finishes by raising an exception.  "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"Функція повернеться, коли будь-який майбутній завершиться, викликавши "
"виняток. Якщо жодне майбутнє не викликає винятку, це еквівалентно :const:"
"`ALL_COMPLETED`."

msgid ":const:`ALL_COMPLETED`"
msgstr ":const:`ALL_COMPLETED`"

msgid "The function will return when all futures finish or are cancelled."
msgstr ""
"Функція повернеться, коли всі ф’ючерси закінчаться або будуть скасовані."

msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
"На відміну від :func:`~asyncio.wait_for`, ``wait()`` не скасовує ф’ючерси, "
"коли настає тайм-аут."

msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task.  Passing coroutines objects to ``wait()`` directly is deprecated as it "
"leads to :ref:`confusing behavior <asyncio_example_wait_coroutine>`."
msgstr ""

msgid ""
"``wait()`` schedules coroutines as Tasks automatically and later returns "
"those implicitly created Task objects in ``(done, pending)`` sets.  "
"Therefore the following code won't work as expected::"
msgstr ""

msgid "Here is how the above snippet can be fixed::"
msgstr ""

msgid "Passing coroutine objects to ``wait()`` directly is deprecated."
msgstr ""

msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently.  Return an iterator of coroutines. Each coroutine returned can "
"be awaited to get the earliest next result from the iterable of the "
"remaining awaitables."
msgstr ""
"Запустіть :ref:`waitable objects <asyncio-awaitables>` в *aws* iterable "
"одночасно. Повертає ітератор співпрограм. Кожну повернуту співпрограму можна "
"очікувати, щоб отримати найраніший наступний результат із ітерації решти "
"очікуваних."

msgid ""
"Raises :exc:`asyncio.TimeoutError` if the timeout occurs before all Futures "
"are done."
msgstr ""

msgid ""
"Deprecation warning is emitted if not all awaitable objects in the *aws* "
"iterable are Future-like objects and there is no running event loop."
msgstr ""
"Якщо не всі очікувані об’єкти в *aws* iterable є об’єктами, подібними до "
"майбутнього, і немає запущеного циклу подій, видається попередження про "
"застаріле."

msgid "Running in Threads"
msgstr "Запуск у потоках"

msgid "Asynchronously run function *func* in a separate thread."
msgstr "Асинхронний запуск функції *func* в окремому потоці."

msgid ""
"Any \\*args and \\*\\*kwargs supplied for this function are directly passed "
"to *func*. Also, the current :class:`contextvars.Context` is propagated, "
"allowing context variables from the event loop thread to be accessed in the "
"separate thread."
msgstr ""
"Будь-які \\*args і \\*\\*kwargs, надані для цієї функції, безпосередньо "
"передаються до *func*. Крім того, поточний :class:`contextvars.Context` "
"поширюється, дозволяючи доступ до змінних контексту з потоку циклу подій в "
"окремому потоці."

msgid ""
"Return a coroutine that can be awaited to get the eventual result of *func*."
msgstr ""
"Повертає співпрограму, яку можна очікувати, щоб отримати кінцевий результат "
"*func*."

msgid ""
"This coroutine function is primarily intended to be used for executing IO-"
"bound functions/methods that would otherwise block the event loop if they "
"were ran in the main thread. For example::"
msgstr ""

msgid ""
"Directly calling `blocking_io()` in any coroutine would block the event loop "
"for its duration, resulting in an additional 1 second of run time. Instead, "
"by using `asyncio.to_thread()`, we can run it in a separate thread without "
"blocking the event loop."
msgstr ""
"Безпосередній виклик `blocking_io()` у будь-якій співпрограмі заблокує цикл "
"подій на весь час, що призведе до додаткової 1 секунди часу виконання. "
"Натомість, використовуючи `asyncio.to_thread()`, ми можемо запустити його в "
"окремому потоці, не блокуючи цикл подій."

msgid ""
"Due to the :term:`GIL`, `asyncio.to_thread()` can typically only be used to "
"make IO-bound functions non-blocking. However, for extension modules that "
"release the GIL or alternative Python implementations that don't have one, "
"`asyncio.to_thread()` can also be used for CPU-bound functions."
msgstr ""
"Завдяки :term:`GIL`, `asyncio.to_thread()` зазвичай можна використовувати "
"лише для того, щоб зробити функції, пов’язані з IO, неблокуючими. Однак для "
"модулів розширення, які випускають GIL або альтернативних реалізацій Python, "
"у яких його немає, `asyncio.to_thread()` також можна використовувати для "
"пов’язаних з ЦП функцій."

msgid "Scheduling From Other Threads"
msgstr "Планування з інших потоків"

msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr "Надішліть співпрограму в заданий цикл подій. Ниткобезпечний."

msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr ""
"Поверніть :class:`concurrent.futures.Future`, щоб дочекатися результату від "
"іншого потоку ОС."

msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"Цю функцію призначено для виклику з потоку ОС, відмінного від того, у якому "
"виконується цикл подій. Приклад::"

msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"Якщо в співпрограмі виникає виняток, буде повідомлено про повернутий Future. "
"Його також можна використовувати для скасування завдання в циклі подій::"

msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Перегляньте розділ :ref:`паралелізм і багатопотоковість <asyncio-"
"multithreading>` документації."

msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr ""
"На відміну від інших асинхронних функцій, ця функція вимагає явної передачі "
"аргументу *loop*."

msgid "Introspection"
msgstr "самоаналіз"

msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""
"Повертає поточний екземпляр :class:`Task` або ``None``, якщо жодне завдання "
"не виконується."

msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""
"Якщо *loop* має значення ``None`` :func:`get_running_loop` використовується "
"для отримання поточного циклу."

msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""
"Повертає набір ще не завершених об’єктів :class:`Task`, які виконуються "
"циклом."

msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""
"Якщо *loop* має значення ``None``, :func:`get_running_loop` використовується "
"для отримання поточного циклу."

msgid "Task Object"
msgstr "Об'єкт завдання"

msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"Об’єкт :class:`подібний до майбутнього <Future>`, який запускає :ref:"
"`сопрограму Python <coroutine>`. Небезпечно для потоків."

msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Завдання використовуються для виконання співпрограм у циклах подій. Якщо "
"співпрограма очікує на Future, Завдання призупиняє виконання співпрограми та "
"чекає завершення Future. Коли Future *done*, виконання загорнутої "
"співпрограми відновлюється."

msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"Цикли подій використовують кооперативне планування: цикл подій виконує одне "
"завдання за раз. Поки Завдання очікує завершення Майбутнього, цикл подій "
"запускає інші Завдання, зворотні виклики або виконує операції введення-"
"виведення."

msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"Використовуйте функцію високого рівня :func:`asyncio.create_task` для "
"створення завдань або функції низького рівня :meth:`loop.create_task` або :"
"func:`ensure_future`. Не рекомендується створювати завдання вручну."

msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"Щоб скасувати запущене завдання, використовуйте метод :meth:`cancel`. Його "
"виклик призведе до того, що завдання створить виняток :exc:`CancelledError` "
"у загорнутій співпрограмі. Якщо співпрограма очікує на об’єкті Future під "
"час скасування, об’єкт Future буде скасовано."

msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress the :exc:"
"`CancelledError` exception and was actually cancelled."
msgstr ""
":meth:`cancelled` можна використовувати, щоб перевірити, чи було скасовано "
"завдання. Метод повертає ``True``, якщо загорнута співпрограма не придушила "
"виняток :exc:`CancelledError` і була фактично скасована."

msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :"
"meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` успадковує від :class:`Future` усі його API, крім :"
"meth:`Future.set_result` і :meth:`Future.set_exception`."

msgid ""
"Tasks support the :mod:`contextvars` module.  When a Task is created it "
"copies the current context and later runs its coroutine in the copied "
"context."
msgstr ""
"Завдання підтримують модуль :mod:`contextvars`. Коли завдання створюється, "
"воно копіює поточний контекст і пізніше виконує свою співпрограму в "
"скопійованому контексті."

msgid "Added support for the :mod:`contextvars` module."
msgstr "Додано підтримку модуля :mod:`contextvars`."

msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr ""
"Якщо *loop* не вказано і немає запущеного циклу подій, видається "
"попередження про застаріле."

msgid "Request the Task to be cancelled."
msgstr "Вимагайте скасування Завдання."

msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr ""
"Це організовує виняток :exc:`CancelledError`, який буде створено в "
"загорнутій співпрограмі в наступному циклі циклу подій."

msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:"
"`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will "
"be cancelled, although suppressing cancellation completely is not common and "
"is actively discouraged."
msgstr ""
"Тоді співпрограма має шанс очистити або навіть відхилити запит, придушивши "
"виняток за допомогою блоку :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally`. Таким чином, на відміну від :meth:"
"`Future.cancel`, :meth:`Task.cancel` не гарантує, що Завдання буде "
"скасовано, хоча повне придушення скасування не є поширеним явищем і активно "
"не рекомендується."

msgid "Added the *msg* parameter."
msgstr "Додано параметр *msg*."

msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""
"Наступний приклад ілюструє, як співпрограми можуть перехопити запит на "
"скасування:"

msgid "Return ``True`` if the Task is *cancelled*."
msgstr "Повертає ``True``, якщо завдання *скасовано*."

msgid ""
"The Task is *cancelled* when the cancellation was requested with :meth:"
"`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` "
"exception thrown into it."
msgstr ""
"Завдання *скасовується*, коли запит на скасування надійшов за допомогою :"
"meth:`cancel`, а загорнута співпрограма поширила виняткову ситуацію :exc:"
"`CancelledError`, яка виникла в ній."

msgid "Return ``True`` if the Task is *done*."
msgstr "Повертає ``True``, якщо завдання *виконано*."

msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""
"Завдання вважається *виконаним*, коли загорнута співпрограма або повернула "
"значення, викликала виняток, або завдання було скасовано."

msgid "Return the result of the Task."
msgstr "Повернути результат Завдання."

msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""
"Якщо завдання *виконано*, повертається результат загорнутої співпрограми "
"(або якщо співпрограма викликала виняток, цей виняток викликається повторно)."

msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr ""
"Якщо завдання було *скасовано*, цей метод викликає виняток :exc:"
"`CancelledError`."

msgid ""
"If the Task's result isn't yet available, this method raises a :exc:"
"`InvalidStateError` exception."
msgstr ""
"Якщо результат завдання ще не доступний, цей метод викликає виняток :exc:"
"`InvalidStateError`."

msgid "Return the exception of the Task."
msgstr "Повернути виняток Завдання."

msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr ""
"Якщо загорнута співпрограма викликала виняток, цей виняток повертається. "
"Якщо загорнута співпрограма повертає нормальний результат, цей метод "
"повертає ``None``."

msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr ""
"Якщо завдання ще не *виконано*, цей метод викликає виняток :exc:"
"`InvalidStateError`."

msgid "Add a callback to be run when the Task is *done*."
msgstr ""
"Додайте зворотний виклик, який буде запущено, коли Завдання *виконано*."

msgid "This method should only be used in low-level callback-based code."
msgstr ""
"Цей метод слід використовувати лише в низькорівневому коді на основі "
"зворотного виклику."

msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""
"Перегляньте документацію :meth:`Future.add_done_callback` для отримання "
"додаткової інформації."

msgid "Remove *callback* from the callbacks list."
msgstr "Видалити *callback* зі списку зворотних викликів."

msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""
"Перегляньте документацію :meth:`Future.remove_done_callback` для отримання "
"додаткової інформації."

msgid "Return the list of stack frames for this Task."
msgstr "Повернути список фреймів стека для цього завдання."

msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr ""
"Якщо загорнуту співпрограму не виконано, це повертає стек, де він був "
"призупинений. Якщо співпрограма завершилася успішно або була скасована, "
"повертається порожній список. Якщо співпрограму було припинено через "
"виняток, повертається список кадрів трасування."

msgid "The frames are always ordered from oldest to newest."
msgstr "Рамки завжди впорядковуються від найстаріших до найновіших."

msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "Для призупиненої співпрограми повертається лише один кадр стека."

msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"Необов'язковий аргумент *limit* встановлює максимальну кількість кадрів для "
"повернення; за замовчуванням повертаються всі доступні кадри. Порядок "
"поверненого списку відрізняється залежно від того, повертається стек чи "
"трасування: повертаються найновіші кадри стеку, але повертаються найстаріші "
"кадри трасування. (Це відповідає поведінці модуля відстеження.)"

msgid "Print the stack or traceback for this Task."
msgstr "Роздрукуйте стек або відстеження для цього завдання."

msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""
"Це створює вихідні дані, подібні до результатів модуля трасування для "
"кадрів, отриманих :meth:`get_stack`."

msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "Аргумент *limit* передається безпосередньо в :meth:`get_stack`."

msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stderr`."
msgstr ""
"Аргумент *file* — це потік введення/виведення, до якого записується вихід; "
"за замовчуванням вихід записується в :data:`sys.stderr`."

msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "Повертає об’єкт співпрограми, обгорнутий :class:`Task`."

msgid "Return the name of the Task."
msgstr "Повернути назву завдання."

msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""
"Якщо Завданню не було явно призначено ім’я, реалізація асинхронного Завдання "
"за замовчуванням генерує ім’я за замовчуванням під час створення екземпляра."

msgid "Set the name of the Task."
msgstr "Встановіть назву завдання."

msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""
"Аргументом *value* може бути будь-який об’єкт, який потім перетворюється на "
"рядок."

msgid ""
"In the default Task implementation, the name will be visible in the :func:"
"`repr` output of a task object."
msgstr ""
"У реалізації Task за замовчуванням ім’я буде видно у виводі :func:`repr` "
"об’єкта task."

msgid "Generator-based Coroutines"
msgstr ""

msgid ""
"Support for generator-based coroutines is **deprecated** and is removed in "
"Python 3.11."
msgstr ""

msgid ""
"Generator-based coroutines predate async/await syntax.  They are Python "
"generators that use ``yield from`` expressions to await on Futures and other "
"coroutines."
msgstr ""

msgid ""
"Generator-based coroutines should be decorated with :func:`@asyncio."
"coroutine <asyncio.coroutine>`, although this is not enforced."
msgstr ""

msgid "Decorator to mark generator-based coroutines."
msgstr ""

msgid ""
"This decorator enables legacy generator-based coroutines to be compatible "
"with async/await code::"
msgstr ""

msgid "This decorator should not be used for :keyword:`async def` coroutines."
msgstr ""

msgid "Use :keyword:`async def` instead."
msgstr ""

msgid "Return ``True`` if *obj* is a :ref:`coroutine object <coroutine>`."
msgstr ""

msgid ""
"This method is different from :func:`inspect.iscoroutine` because it returns "
"``True`` for generator-based coroutines."
msgstr ""

msgid "Return ``True`` if *func* is a :ref:`coroutine function <coroutine>`."
msgstr ""

msgid ""
"This method is different from :func:`inspect.iscoroutinefunction` because it "
"returns ``True`` for generator-based coroutine functions decorated with :"
"func:`@coroutine <coroutine>`."
msgstr ""
